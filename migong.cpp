/*      迷宫的最短路径
    给定一个大小为 N×M的迷宫。迷宫由通道和墙壁组成，
    每一步可以向邻接的上下左右四格 的通道移动。
    请求出从起点到终点所需的小步数。
    请注意，本题假定从起点一定可以移动到终点。

    限制条件  N, M ≤ 100 

    输入
        N=10, M=10
    （迷宫如下图所示。'#'，'.'，'S'，'G'分别表示墙壁、通道、起点和终点） 
    #S######.# 
    ......#..# 
    .#.##.##.# 
    .#........ 
    ##.##.#### 
    ....#....# 
    .#######.# 
    ....#..... 
    .####.###. 
    ....#...G# 

    输出 22 

*/

/*  宽度优先搜索按照距开始状态由近及远的顺序进行搜索，
    因此可以很容易地用来求短路径、 少操作之类问题的答案。
    这个问题中，状态仅仅是目前所在位置的坐标，因此可以构造成pair 
    或者编码成int来表达状态。
    当状态更加复杂时，就需要封装成一个类来表示状态了。
    转移的方式为四方向移动，状态数与迷宫的大小是相等的，
    所以复杂度是O(4×N×M)=O(N×M)。

    宽度优先搜索中，只要将已经访问过的状态用标记管理起来，
    就可以很好地做到由近及远的搜索。 
    这个问题中由于要求短距离，不妨用d[N][M]数组把短距离保存起来。
    初始时用充分大的常数INF来初始化它，这样尚未到达的位置就是INF，
    也就同时起到了标记的作用。 虽然到达终点时就会停止搜索，
    可如果继续下去直到队列为空的话，就可以计算出到各个位置的短距离。
    此外，如果搜索到后，d依然为INF的话，
    便可得知这个位置就是无法从起点到达的位置。

    在今后的程序中，使用像INF这样充分大的常数的情况还很多。
    不把INF当作例外，而是直接参与普通运算的情况也很常见。
    这种情况下，如果INF过大就可能带来溢出的危险。 
    假设INF=231-1。
    例如想用d[nx][ny]=min(d[nx][ny], d[x][y]+1)来更新d[nx][ny]，
    就会发生INF+1=-231的情况。
    这一问题中d[x][y]总不等于INF，所以没有问题。
    但是为了防止这样 的问题，一般会将INF设为放大2~4倍也不会溢出的大小
    （可参考2.5节Floyd-Warshall算法等）。 
    因为要向4个不同方向移动，用dx[4]和dy[4]两个数组来表示四个方向向量。
    这样通过一个循 环就可以实现四方向移动的遍历。

*/ 

const int INF = 100000000;

// 使用 pair 表示状态时，使用 typedef 会更方便一些
typedef pair<int , int> P;

// 输入
char maze[MAX_N][MAX_M + 1];    // 表示迷宫的字符串数组
int N, M;
int sx, sy;                     // 起点坐标
int gx, gy;                     // 终点坐标

int d[MAX_N][MAX_M];            // 到各个点最短距离的数组

// 4 个方向移动的向量
int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};

// 求从（sx，sy）到（gx，gy）的最短距离
// 如果无法到达，即为 INF
int dfs() {
    queue<P> que;
    // 把所有的位置都初始化为 INF
    for(int i = 0; i < N; i++) 
        for(int j = 0; j < M; j++)
            d[i][j] = INF;
    // 将起点加入队列，并把这一地点的距离设为 0
    que.push(P(sx,sy));
    d[sx][sy] = 0;

    // 不断循环直到队列的长度为 0
    while(que.size()) {
        // 从队列最前端取出元素
        P p  = que.front();
        que.pop();
        // 如果取出的状态已经是终点，则结束搜索
        if(p.first == gx && p.second == gy) break;
        
        // 四个方向的循环
        for(int i = 0; i < 4; i++) {
            // 移动之后的位置记为（nx，ny）
            int nx = p.first + dx[i];
            int ny = p.second + dy[i];

            // 判断是否移动以及是否已经访问过
            // d[nx][ny] != INF 即为已经访问过
            if(0 <= nx && nx < N && 0 <= ny && ny < M && 
                maze[nx][ny] != '#' && d[nx][ny] == INF) {
                    // 可以移动的话，则加入队列，并且到该位置的距离
                    // 确定为p + 1
                    que.push(P(nx, ny));
                    d[nx][ny] = d[p.first][p.second] + 1;
                }
        }
    }
    return d[gx][gy];
}

void solve() {
    int res = bfs();
    printf("%d\n", res);
}